## Бизнес‑требования к онлайн‑магазину книг

### Функциональные требования

- **Регистрация и аутентификация пользователей**
  - Пользователь может зарегистрироваться по email и паролю.
  - Пользователь может войти в систему и получить JWT‑токен.
  - Пользователь может получить информацию о себе (`/auth/me`).

- **Роли и права доступа**
  - Роли: `user`, `admin`.
  - Роль `admin`:
    - может создавать, изменять и просматривать книги в каталоге;
    - может импортировать книги по ISBN из внешнего API.
  - Роль `user`:
    - может просматривать каталог;
    - может формировать корзину и создавать заказы.

- **Каталог книг**
  - Хранение книг с атрибутами: название, описание, автор, категории, цена, ISBN.
  - Возможность поиска и фильтрации по:
    - ключевой строке (название/описание),
    - автору,
    - категории,
    - постраничный вывод результатов.
  - Импорт книги по ISBN из внешнего публичного API (Open Library или Google Books).
  - Учёт остатков на складе (stock) по каждой книге.

- **Корзина и заказы**
  - Пользователь может:
    - добавлять книги в корзину и изменять их количество;
    - просматривать текущую корзину;
    - создавать заказ на основе содержимого корзины.
  - При создании заказа:
    - происходит обращение к `catalog-service` для получения цен;
    - создаются записи `Order` и `OrderItems` в БД заказов;
    - корзина очищается.

- **Асинхронное резервирование стока**
  - После создания заказа:
    - `order-service` публикует событие `order.created` в RabbitMQ;
    - `order-service` публикует событие `stock.reserve.request` для резервирования товара на складе.
  - `catalog-service`:
    - подписан на `stock.reserve.request`;
    - проверяет наличие достаточного количества книг в таблице `stock`;
    - в случае успеха уменьшает остатки и публикует `stock.reserve.succeeded`;
    - в случае нехватки — публикует `stock.reserve.failed`.
  - `order-service` (по проектному замыслу) обрабатывает события `stock.reserve.succeeded/failed` и меняет статус заказа.
  - `analytics-service` подписан на все события и сохраняет их в свою БД.

### Нефункциональные требования

- **Авторизация и безопасность**
  - Все защищённые эндпоинты требуют JWT‑токен в заголовке `Authorization: Bearer <token>`.
  - Пароли в БД хранятся только в виде bcrypt‑хэшей.
  - Проверка роли (`user/admin`) выполняется на уровне эндпоинтов.

- **Отсутствие HTTP 500 для любых входных данных**
  - Пользовательские ошибки (валидация, бизнес‑правила) возвращают коды 4xx (`400/401/403/404/409`).
  - Непредвиденные ошибки (сбои БД, RabbitMQ и т.п.) перехватываются глобальными обработчиками и возвращают код `503 Service Unavailable` с контролируемым форматом ошибки.
  - Используются:
    - Pydantic‑модели для валидации входных данных;
    - глобальные `exception_handler` для `HTTPException`, `RequestValidationError` и всех `Exception`.

- **Формат ошибок**
  - Унифицированный формат для всех сервисов:
    ```json
    {
      "error_code": "STRING_CODE",
      "message": "Человеко-читаемое описание",
      "details": { "context": "произвольные данные" }
    }
    ```

- **Логирование и трассировка**
  - Используется JSON‑логирование на базе `structlog`.
  - Во все логи пробрасывается `correlation_id`, который:
    - генерируется middleware, если не был передан клиентом;
    - возвращается в заголовке `X-Correlation-Id` у всех ответов.
  - Логи включают ключевые события: создание пользователей, книг, заказов, публикация/обработка событий.

- **Брокер сообщений**
  - Используется RabbitMQ:
    - exchange: `bookstore.events` (тип: topic);
    - routing keys:
      - `order.created`
      - `stock.reserve.request`
      - `stock.reserve.succeeded`
      - `stock.reserve.failed`.
  - Асинхронное взаимодействие:
    - сервисы не ждут синхронного ответа от брокера;
    - за резервирование стока отвечает `catalog-service`.

- **Хранение данных**
  - Минимум одна SQL‑БД — фактически 4 отдельные БД (`auth_db`, `catalog_db`, `order_db`, `analytics_db`) в одном экземпляре PostgreSQL.
  - Доступ к БД выполняется через SQLAlchemy ORM (async engine).
  - Миграции схемы — через Alembic (для каждого сервиса свой набор миграций).

- **Надёжность и удобство эксплуатации**
  - Каждый сервис имеет эндпоинт `/health`, пригодный для health‑checks.
  - Стек разворачивается через `docker-compose` одной командой.
  - OpenAPI/Swagger доступны по `/docs` и `/openapi.json` для каждого микросервиса.


